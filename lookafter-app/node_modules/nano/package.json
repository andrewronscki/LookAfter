{
  "_args": [
    [
      {
        "raw": "nano",
        "scope": null,
        "escapedName": "nano",
        "name": "nano",
        "rawSpec": "",
        "spec": "latest",
        "type": "tag"
      },
      "C:\\Users\\ANDRE\\Desktop\\LooKAfterBackend"
    ]
  ],
  "_from": "nano",
  "_hasShrinkwrap": false,
  "_id": "nano@8.0.1",
  "_location": "/nano",
  "_nodeVersion": "10.14.0",
  "_npmOperationalInternal": {
    "host": "s3://npm-registry-packages",
    "tmp": "tmp/nano_8.0.1_1552898332595_0.29362628694714266"
  },
  "_npmUser": {
    "name": "glynnbird",
    "email": "glynn.bird@gmail.com"
  },
  "_npmVersion": "6.5.0",
  "_phantomChildren": {},
  "_requested": {
    "raw": "nano",
    "scope": null,
    "escapedName": "nano",
    "name": "nano",
    "rawSpec": "",
    "spec": "latest",
    "type": "tag"
  },
  "_requiredBy": [
    "#USER",
    "/"
  ],
  "_resolved": "https://registry.npmjs.org/nano/-/nano-8.0.1.tgz",
  "_shasum": "e60488406b1ad1d5b50ac2fe21d6b178a98754d8",
  "_shrinkwrap": null,
  "_spec": "nano",
  "_where": "C:\\Users\\ANDRE\\Desktop\\LooKAfterBackend",
  "author": {
    "name": "Apache CouchDB",
    "email": "dev@couchdb.apache.org",
    "url": "http://couchdb.apache.org"
  },
  "bugs": {
    "url": "https://github.com/apache/couchdb-nano/issues"
  },
  "dependencies": {
    "@types/request": "^2.47.1",
    "cloudant-follow": "^0.18.0",
    "debug": "^2.2.0",
    "errs": "^0.3.2",
    "request": "^2.85.0"
  },
  "description": "The official CouchDB client for Node.js",
  "devDependencies": {
    "async": "^2.1.2",
    "istanbul": "^0.4.5",
    "nock": "^9.6.1",
    "standard": "^11.0.1",
    "tape": "^4.6.2"
  },
  "directories": {},
  "dist": {
    "integrity": "sha512-q9q8894oLNyWHhsUjF4Nk9gAvGorsCrmx0aeA7AG9pYRnM+xtAKVX5GtWfW8c2qx4mJftXHeN1/6RR8Oo9eQaQ==",
    "shasum": "e60488406b1ad1d5b50ac2fe21d6b178a98754d8",
    "tarball": "https://registry.npmjs.org/nano/-/nano-8.0.1.tgz",
    "fileCount": 138,
    "unpackedSize": 333511,
    "npm-signature": "-----BEGIN PGP SIGNATURE-----\r\nVersion: OpenPGP.js v3.0.4\r\nComment: https://openpgpjs.org\r\n\r\nwsFcBAEBCAAQBQJcj1kdCRA9TVsSAnZWagAAjaQQAJQV5OctCiuL2aovkIy4\n32aU0dFxgyasnyJ4FUauP+4pGeggVwfwtejHdD6ITKEFQtV1DJzC+ISR83Pc\n5XSeRSUH/LFPGcOwunDlR3xh2k/l76tvHHYRj0ZtAg9zB1x0cHyG7Ztiw+38\nhadtmRzxX+f0wppxSc1l2M5X8yY9idqzX7pAducluDyb9Y+zDVSHTUbvx2Up\nQ6XgAYL4lf0I7KFpoMDtE5s5bhQ8Ax8nfkhv12yewmVvyGoIxlrZadWXh1Bu\n9csP1EKGMbv88mo1i+nPAmt47lZfBy7J5wHrhE8mgUDZLH+BDoO/4R9/knDN\nMb+SP15Ej8aHyvgdae1nmjlwuJ6sDOZFJ8SRNzw5lOQ/foUnFdklLSqRMXks\ntB/NBzuIYKksJSPqIrnunRVjpUAfJyr6mSEdr0kSEY5RxbZU1hgMKqjGcRcK\nwYLExOOGgjslCQFuKT4kA1e05aXKZjFEujrIJV1wjCr/VS4W2F/iheWgmgqR\n0qBBH5/QU+eMx0xd1oHySpnOdr07UI/Uj8KLkp+V8FdEkNqNOWYzdbBuTs5+\neHeBxaqdR8bslTIo3fDnVOEBwAWlz3OKUEgI16S4TmhgR5nMv/VvcLr2uNhQ\nFLsn97sKhOif10K6PVB70aEMyBLT9NxYwMFXpDQYnlYS8sSU12yX4XC7VlGv\nhYUC\r\n=pSPc\r\n-----END PGP SIGNATURE-----\r\n"
  },
  "engines": {
    "node": ">=6"
  },
  "gitHead": "19b5a2dcf64b85f0d824a472887a5ca4dacc9c3f",
  "homepage": "http://github.com/apache/couchdb-nano",
  "keywords": [
    "couchdb",
    "data",
    "request",
    "json",
    "nosql",
    "micro",
    "nano",
    "database"
  ],
  "license": "Apache-2.0",
  "main": "./lib/nano.js",
  "maintainers": [
    {
      "name": "dscape",
      "email": "nunojobpinto@gmail.com"
    },
    {
      "name": "garrensmith",
      "email": "garren.smith@gmail.com"
    },
    {
      "name": "glynnbird",
      "email": "glynn.bird@gmail.com"
    },
    {
      "name": "jan",
      "email": "jan@apache.org"
    },
    {
      "name": "jhs",
      "email": "jason.h.smith@gmail.com"
    },
    {
      "name": "jo",
      "email": "schmidt@netzmerk.com"
    },
    {
      "name": "pgte",
      "email": "i@pgte.me"
    }
  ],
  "name": "nano",
  "optionalDependencies": {},
  "pre-commit": [
    "mocked",
    "test",
    "checkcoverage"
  ],
  "readme": "[![Build Status](https://travis-ci.org/apache/couchdb-nano.svg?branch=master)](https://travis-ci.org/apache/couchdb-nano)![Coverage](https://img.shields.io/badge/coverage-100%-ff69b4.svg)[![dependencies Status](https://david-dm.org/apache/couchdb-nano/status.svg)](https://david-dm.org/apache/couchdb-nano)[![NPM](http://img.shields.io/npm/v/nano.svg?style=flat-square)](https://www.npmjs.com/package/nano)\n\n# Nano\n\nOffical [Apache CouchDB](http://couchdb.apache.org/) library for [Node.js](https://nodejs.org/).\n\nFeatures:\n\n* **Minimalistic** - There is only a minimum of abstraction between you and\n  CouchDB.\n* **Pipes** - Proxy requests from CouchDB directly to your end user. ( `...AsStream` functions only)\n* **Promises** - The vast majority of library calls return native Promises.\n* **TypeScript** - Detailed TypeScript definitions are built in.\n* **Errors** - Errors are proxied directly from CouchDB: if you know CouchDB\n  you already know `nano`.\n\n## Installation\n\n1. Install [npm][1]\n2. `npm install nano`\n\nor save `nano` as a dependency of your project with\n\n    npm install --save nano\n\nNote the minimum required version of Node.js is 6.\n\nSee [Migration Guide for switching from Nano 6.x to 7.x](migration_6_to_7.md).\n\n## Table of contents\n\n- [Getting started](#getting-started)\n- [Tutorials & screencasts](#tutorials-examples-in-the-wild--screencasts)\n- [Configuration](#configuration)\n- [Database functions](#database-functions)\n  - [nano.db.create(name, [callback])](#nanodbcreatename-callback)\n  - [nano.db.get(name, [callback])](#nanodbgetname-callback)\n  - [nano.db.destroy(name, [callback])](#nanodbdestroyname-callback)\n  - [nano.db.list([callback])](#nanodblistcallback)\n  - [nano.db.listAsStream()](#nanodblistasstream)\n  - [nano.db.compact(name, [designname], [callback])](#nanodbcompactname-designname-callback)\n  - [nano.db.replicate(source, target, [opts], [callback])](#nanodbreplicatesource-target-opts-callback)\n  - [nano.db.replication.enable(source, target, [opts], [callback])](#nanodbreplicationenablesource-target-opts-callback)\n  - [nano.db.replication.query(id, [opts], [callback])](#nanodbreplicationenablesource-target-opts-callback)\n  - [nano.db.replication.disable(id, [opts], [callback])](#nanodbreplicationdisableid-opts-callback)\n  - [nano.db.changes(name, [params], [callback])](#nanodbchangesname-params-callback)\n  - [nano.db.changesAsStream(name, [params])](#nanodbchangesasstreamname-params)\n  - [nano.db.follow(name, [params], [callback])](#nanodbfollowname-params-callback)\n  - [nano.db.info([callback])](#nanodbinfocallback)\n  - [nano.use(name)](#nanousename)\n  - [nano.request(opts, [callback])](#nanorequestopts-callback)\n  - [nano.config](#nanoconfig)\n  - [nano.updates([params], [callback])](#nanoupdatesparams-callback)\n  - [nano.followUpdates([params], [callback])](#nanofollowupdatesparams-callback)\n- [Document functions](#document-functions)\n  - [db.insert(doc, [params], [callback])](#dbinsertdoc-params-callback)\n  - [db.destroy(docname, rev, [callback])](#dbdestroydocname-rev-callback)\n  - [db.get(docname, [params], [callback])](#dbgetdocname-params-callback)\n  - [db.head(docname, [callback])](#dbheaddocname-callback)\n  - [db.copy(src_doc, dest_doc, opts, [callback])](#dbcopysrc_doc-dest_doc-opts-callback)\n  - [db.bulk(docs, [params], [callback])](#dbbulkdocs-params-callback)\n  - [db.list([params], [callback])](#dblistparams-callback)\n  - [db.listAsStream([params])](#dblistasstreamparams)\n  - [db.fetch(docnames, [params], [callback])](#dbfetchdocnames-params-callback)\n  - [db.fetchRevs(docnames, [params], [callback])](#dbfetchrevsdocnames-params-callback)\n  - [db.createIndex(indexDef, [callback])](#dbcreateindexindexdef-callback)\n- [Multipart functions](#multipart-functions)\n  - [db.multipart.insert(doc, attachments, [params], [callback])](#dbmultipartinsertdoc-attachments-params-callback)\n  - [db.multipart.get(docname, [params], [callback])](#dbmultipartgetdocname-params-callback)\n- [Attachments functions](#attachments-functions)\n  - [db.attachment.insert(docname, attname, att, contenttype, [params], [callback])](#dbattachmentinsertdocname-attname-att-contenttype-params-callback)\n  - [db.attachment.insertAsStream(docname, attname, att, contenttype, [params])](#dbattachmentinsertasstreamdocname-attname-att-contenttype-params)\n  - [db.attachment.get(docname, attname, [params], [callback])](#dbattachmentgetdocname-attname-params-callback)\n  - [db.attachment.getAsStream(docname, attname, [params])](#dbattachmentgetasstreamdocname-attname-params)\n  - [db.attachment.destroy(docname, attname, [params], [callback])](#dbattachmentdestroydocname-attname-params-callback)\n- [Views and design functions](#views-and-design-functions)\n  - [db.view(designname, viewname, [params], [callback])](#dbviewdesignname-viewname-params-callback)\n  - [db.viewAsStream(designname, viewname, [params])](#dbviewasstreamdesignname-viewname-params)\n  - [db.show(designname, showname, doc_id, [params], [callback])](#dbshowdesignname-showname-doc_id-params-callback)\n  - [db.atomic(designname, updatename, docname, [body], [callback])](#dbatomicdesignname-updatename-docname-body-callback)\n  - [db.search(designname, viewname, params, [callback])](#dbsearchdesignname-searchname-params-callback)\n  - [db.searchAsStream(designname, viewname, params)](#dbsearchasstreamdesignname-searchname-params)\n  - [db.find(selector, [callback])](#dbfindselector-callback)\n  - [db.findAsStream(selector)](#dbfindasstreamselector)\n- [Using cookie authentication](#using-cookie-authentication)\n- [Advanced features](#advanced-features)\n  - [getting uuids](#getting-uuids)\n  - [extending nano](#extending-nano)\n  - [pipes](#pipes)\n- [Tests](#tests)\n- [Release](#release)\n\n## Getting started\n\nTo use `nano` you need to connect it to your CouchDB install, to do that:\n\n```js\nconst nano = require('nano')('http://localhost:5984');\n```\n\nThe URL you supply may also contain authenication credentials e.g. `http://admin:mypassword@localhost:5984`.\n\nTo create a new database:\n\n```js\nnano.db.create('alice');\n```\n\nand to use an existing database:\n\n```js\nconst alice = nano.db.use('alice');\n```\n\nUnder-the-hood, calls like `nano.db.create` are making HTTP API calls to the CouchDB service. Such operations are *asynchronous*. There are two ways to recieve the asynchronous data back from the library\n\n1) Promises\n\n```js\nnano.db.create('alice').then((data) => {\n  // success - response is in 'data'\n}).catch((err) => {\n  // failure - error information is in 'err'\n})\n```\n\n2) Callbacks\n\n```js\nnano.db.create('alice', (err, data) => {\n  // errors are in 'err' & response is in 'data'\n})\n```\n\nIn `nano` the callback function receives always three arguments:\n\n* `err` - The error, if any.\n* `body` - The HTTP _response body_ from CouchDB, if no error.\n  JSON parsed body, binary for non JSON responses.\n* `header` - The HTTP _response header_ from CouchDB, if no error.\n\nThe documentation will now follow the *Promises* style.\n\n------------------\n\n\nA simple but complete example in the [async/await](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/async_function) style:\n\n```js\nasync function asyncCall() {\n  await nano.db.destroy('alice')\n  await nano.db.create('alice')\n  const alice = nano.use('alice')\n  const response = await alice.insert({ happy: true }, 'rabbit')\n  return response\n}\nasyncCall()\n```\n\nor in the raw Promises-style\n\n```js\nconst nano = require('nano')('http://localhost:5984');\nlet alice;\n\nnano.db.destroy('alice').then((response) => {\n  return nano.db.create('alice')\n}).then((response) =>  {\n  alice = nano.use('alice')\n  return alice.insert({ happy: true }, 'rabbit')\n}).then((response) => {\n  console.log('you have inserted a document with an _id of rabbit')\n  console.log(response);\n})\n```\n\nIf you run either of these examples (after starting CouchDB) you will see:\n\n```\nyou have inserted a document with an _id of rabbit.\n{ ok: true,\n  id: 'rabbit',\n  rev: '1-6e4cb465d49c0368ac3946506d26335d' }\n```\n\nYou can also see your document in [futon](http://localhost:5984/_utils).\n\n## Configuration\n\nConfiguring nano to use your database server is as simple as:\n\n```js\nconst nano = require('nano')('http://localhost:5984')\nconst db = nano.use('foo');\n```\n\nIf you don't need to instrument database objects you can simply:\n\n```js\n// nano parses the URL and knows this is a database\nconst db = require('nano')('http://localhost:5984/foo');\n```\n\nYou can also pass options to the require to specify further configuration options you can pass an object literal instead:\n\n```js\n// nano parses the URL and knows this is a database\nconst opts = {\n  url: \"http://localhost:5984/foo\",\n  requestDefaults: { \"proxy\" : \"http://someproxy\" },\n  log: (id, args) => {\n    console.log(id, args);\n  }\n};\nconst db = require('nano')(opts);\n```\n\nPlease check [request] for more information on the defaults. They support features like cookie jar, proxies, ssl, etc.\n\nYou can tell nano to not parse the URL (maybe the server is behind a proxy, is accessed through a rewrite rule or other):\n\n```js\n// nano does not parse the URL and return the server api\n// \"http://localhost:5984/prefix\" is the CouchDB server root\nconst couch = require('nano')(\n  { url : \"http://localhost:5984/prefix\"\n    parseUrl : false\n  });\nconst db = couch.use('foo');\n```\n\n### Pool size and open sockets\n\nA very important configuration parameter if you have a high traffic website and are using `nano` is setting up the `pool.size`. By default, the Node.js HTTP global agent (client) has a certain size of active connections that can run simultaneously, while others are kept in a queue. Pooling can be disabled by setting the `agent` property in `requestDefaults` to `false`, or adjust the global pool size using:\n\n```js\nhttp.globalAgent.maxSockets = 20;\n```\n\nYou can also increase the size in your calling context using `requestDefaults` if this is problematic. Refer to the [request] documentation and examples for further clarification.\n\nHere's an example explicitly using the keep alive agent (installed using `npm install agentkeepalive`), especially useful to limit your open sockets when doing high-volume access to CouchDB on localhost:\n\n```js\nconst agentkeepalive = require('agentkeepalive');\nconst myagent = new agentkeepalive({\n  maxSockets: 50,\n  maxKeepAliveRequests: 0,\n  maxKeepAliveTime: 30000\n});\n\nconst db = require('nano')(\n  { url: \"http://localhost:5984/foo\",\n    requestDefaults : { \"agent\" : myagent }\n  });\n```\n\n## TypeScript\n\nThere is a full TypeScript definition included in the the *nano* package. Your TypeScript editor will show you hints as you write your code with the *nano* library with your own custom classes:\n\n```ts\nimport * as Nano  from 'nano'\n\nlet n = Nano('http://USERNAME:PASSSWORD@localhost:5984')\nlet db = n.db.use('people')\n\ninterface iPerson extends Nano.MaybeDocument {\n  name: string,\n  dob: string\n}\n\nclass Person implements iPerson {\n  _id: string\n  _rev: string\n  name: string\n  dob: string\n\n  constructor(name: string, dob: string) {\n    this._id = undefined\n    this._rev = undefined\n    this.name = name\n    this.dob = dob\n  }\n\n  processAPIResponse(response: Nano.DocumentInsertResponse) {\n    if (response.ok === true) {\n      this._id = response.id\n      this._rev = response.rev\n    }\n  }\n}\n\nlet p = new Person('Bob', '2015-02-04')\ndb.insert(p).then((response) => {\n  p.processAPIResponse(response)\n  console.log(p)\n})\n```\n\n## Database functions\n\n### nano.db.create(name, [callback])\n\nCreates a CouchDB database with the given `name`:\n\n```js\nnano.db.create('alice').then((body) => {\n  console.log('database alice created!');\n})\n```\n\n### nano.db.get(name, [callback])\n\nGet information about the database `name`:\n\n```js\nnano.db.get('alice').then((body) => {\n  console.log(body);\n})\n```\n\n### nano.db.destroy(name, [callback])\n\nDestroys the database `name`:\n\n```js\nnano.db.destroy('alice').then((body) => {\n  // database destroyed\n})\n```\n\n### nano.db.list([callback])\n\nLists all the CouchDB databases:\n\n```js\nnano.db.list().then((body) => {\n  // body is an array\n  body.forEach((db) => {\n    console.log(db);\n  });\n});\n```\n\n### nano.db.listAsStream()\n\nLists all the CouchDB databases as a stream:\n\n```js\nnano.db.list().pipe(process.stdout);\n```\n\n### nano.db.compact(name, [designname], [callback])\n\nCompacts `name`, if `designname` is specified also compacts its views.\n\n### nano.db.replicate(source, target, [opts], [callback])\n\nReplicates `source` to `target` with options `opts`. The `target`database\nhas to exist, add `create_target:true` to `opts` to create it prior to\nreplication:\n\n```js\nnano.db.replicate('alice', 'http://admin:password@otherhost.com:5984/alice',\n                  { create_target:true }).then((body) => {\n  console.log(body);\n});\n```\n\n### nano.db.replication.enable(source, target, [opts], [callback])\n\nEnables replication using the new CouchDB api from `source` to `target`\nwith options `opts`. `target` has to exist, add `create_target:true` to\n`opts` to create it prior to replication. Replication will survive server restarts.\n\n```js\nnano.db.replication.enable('alice', 'http://admin:password@otherhost.com:5984/alice',\n                  { create_target:true }).then((body) => {\n  console.log(body);\n});\n```\n\n### nano.db.replication.query(id, [opts], [callback])\n\nQueries the state of replication using the new CouchDB API. The `id` comes from the response\ngiven by the call to `replication.enable`:\n\n```js\nnano.db.replication.enable('alice', 'http://admin:password@otherhost.com:5984/alice',\n                   { create_target:true }).then((body) => {\n  return nano.db.replication.query(body.id);\n}).then((response) => {\n  console.log(response);\n});\n```\n\n### nano.db.replication.disable(id, [opts], [callback])\n\nDisables replication using the new CouchDB API. The `id` comes from the response given\nby the call to `replication.enable`:\n\n```js\nnano.db.replication.enable('alice', 'http://admin:password@otherhost.com:5984/alice',\n                   { create_target:true }).then((body) => {\n  return nano.db.replication.disable(body.id);\n}).then((response) => {\n  console.log(response);\n});\n```\n\n### nano.db.changes(name, [params], [callback])\n\nAsks for the changes feed of `name`, `params` contains additions\nto the query string.\n\n```js\nnano.db.changes('alice').then((body) => {\n  console.log(body);\n});\n```\n\n### nano.db.changesAsStream(name, [params])\n\nSame as `nano.db.changes` but returns a stream.\n\n```js\nnano.db.changes('alice').pipe(process.stdout);\n```\n\n### nano.db.follow(name, [params], [callback])\n\nUses [Follow] to create a solid changes feed. Please consult `follow` documentation for more information as this is a very complete API on it's own:\n\n```js\nconst feed = db.follow({since: \"now\"});\nfeed.on('change', (change) => {\n  console.log(\"change: \", change);\n});\nfeed.follow();\nprocess.nextTick( () => {\n  db.insert({\"bar\": \"baz\"}, \"bar\");\n});\n```\n\n### nano.db.info([callback])\n\nGets database information:\n\n```js\nnano.db.info().then((body) => {\n  console.log('got database info', body);\n});\n```\n\n### nano.use(name)\n\nReturns a database object that allows you to perform operations against that database:\n\n```js\nconst alice = nano.use('alice');\nalice.insert({ happy: true }, 'rabbit').then((body) => {\n  // do something\n});\n```\n\n### nano.db.use(name)\n\nAlias for `nano.use`\n\n### nano.db.scope(name)\n\nAlias for `nano.use`\n\n### nano.scope(name)\n\nAlias for `nano.use`\n\n### nano.request(opts, [callback])\n\nMakes a custom request to CouchDB. This can be used to create your own HTTP request to the CouchDB\nserver, to perform operations where there is no `nano` function that encapsulates it. The available `opts` are:\n\n* `opts.db` – the database name\n* `opts.method` – the http method, defaults to `get`\n* `opts.path` – the full path of the request, overrides `opts.doc` and\n  `opts.att`\n* `opts.doc` – the document name\n* `opts.att` – the attachment name\n* `opts.qs` – query string parameters, appended after any existing `opts.path`, `opts.doc`, or `opts.att`\n* `opts.content_type` – the content type of the request, default to `json`\n* `opts.headers` – additional http headers, overrides existing ones\n* `opts.body` – the document or attachment body\n* `opts.encoding` – the encoding for attachments\n* `opts.multipart` – array of objects for multipart request\n* `opts.stream` - if `true`, a `request` object is returned. Default `false` and a Promise is returned.\n\n### nano.relax(opts, [callback])\n\nAlias for `nano.request`\n\n### nano.config\n\nAn object containing the `nano` configurations, possible keys are:\n\n* `url` - the CouchDB URL\n* `db` - the database name\n\n### nano.updates([params], [callback])\n\nListen to db updates, the available `params` are:\n\n* `params.feed` – Type of feed. Can be one of\n * `longpoll`: Closes the connection after the first event.\n * `continuous`: Send a line of JSON per event. Keeps the socket open until timeout.\n * `eventsource`: Like, continuous, but sends the events in EventSource format.\n* `params.timeout` – Number of seconds until CouchDB closes the connection. Default is 60.\n* `params.heartbeat` – Whether CouchDB will send a newline character (\\n) on timeout. Default is true.\n\n### nano.followUpdates([params], [callback])\n\n** changed in version 6 **\n\nUse [Follow] to create a solid\n[`_db_updates`](http://docs.couchdb.org/en/latest/api/server/common.html?highlight=db_updates#get--_db_updates) feed.\nPlease consult follow documentation for more information as this is a very complete api on it's own\n\n```js\nconst feed = nano.followUpdates({since: \"now\"});\nfeed.on('change', (change) => {\n  console.log(\"change: \", change);\n});\nfeed.follow();\nprocess.nextTick( () => {\n  nano.db.create('alice');\n});\n```\n\n## Document functions\n\n### db.insert(doc, [params], [callback])\n\nInserts `doc` in the database with optional `params`. If params is a string, it's assumed it is the intended document `_id`. If params is an object, it's passed as query string parameters and `docName` is checked for defining the document `_id`:\n\n```js\nconst alice = nano.use('alice');\nalice.insert({ happy: true }, 'rabbit').then((body) => {\n  console.log(body);\n});\n```\n\nThe `insert` function can also be used with the method signature `db.insert(doc,[callback])`, where the `doc` contains the `_id` field e.g.\n\n```js\nconst alice = nano.use('alice')\nalice.insert({ _id: 'myid', happy: true }).then((body) => {\n  console.log(body)\n})\n```\n\nand also used to update an existing document, by including the `_rev` token in the document being saved:\n\n```js\nconst alice = nano.use('alice')\nalice.insert({ _id: 'myid', _rev: '1-23202479633c2b380f79507a776743d5', happy: false }).then((body) => {\n  console.log(body)\n})\n```\n\n### db.destroy(docname, rev, [callback])\n\nRemoves a document from CouchDB whose `_id` is `docname` and who's revision is `_rev`:\n\n```js\nalice.destroy('rabbit', '3-66c01cdf99e84c83a9b3fe65b88db8c0').then((body) => {\n  console.log(body);\n});\n```\n\n### db.get(docname, [params], [callback])\n\nGets a document from CouchDB whose `_id` is `docname`:\n\n```js\nalice.get('rabbit').then((body) => {\n  console.log(body);\n});\n```\n\nor with optional query string `params`:\n\n```js\nalice.get('rabbit', { revs_info: true }).then((body) => {\n  console.log(body);\n});\n```\n\n### db.head(docname, [callback])\n\nSame as `get` but lightweight version that returns headers only:\n\n```js\nalice.head('rabbit').then((headers) => {\n  console.log(headers);\n});\n```\n\n*Note:* if you call `alice.head` in the callback style, the headers are returned to you as the third argument of the callback function.\n\n### db.copy(src_doc, dest_doc, opts, [callback])\n\nCopies the contents (and attachments) of a document\nto a new document, or overwrite an existing target document\n\n```js\nalice.copy('rabbit', 'rabbit2', { overwrite: true }).then((body) => {\n  console.log(body);\n});\n```\n\n### db.bulk(docs, [params], [callback])\n\nBulk operations(update/delete/insert) on the database, refer to the\n[CouchDB doc](http://docs.couchdb.org/en/2.1.1/api/database/bulk-api.html#db-bulk-docs) e.g:\n\n```js\nconst documents = [\n  { a:1, b:2 },\n  { _id: 'tiger', striped: true}\n];\nalice.bulk({docs:documents}).then((body) => {\n  console.log(body);\n});\n```\n\n### db.list([params], [callback])\n\nList all the docs in the database .\n\n```js\nalice.list().then((body) => {\n  body.rows.forEach((doc) => {\n    console.log(doc);\n  });\n});\n```\n\nor with optional query string additions `params`:\n\n```js\nalice.list({include_docs: true}).then((body) => {\n  body.rows.forEach((doc) => {\n    // output eacj document's body\n    console.log(doc.doc);\n  });\n});\n```\n\n### db.listAsStream([params])\n\nList all the docs in the database as a stream.\n\n```js\nalice.list().pipe(process.stdout)\n```\n\n### db.fetch(docnames, [params], [callback])\n\nBulk fetch of the database documents, `docnames` are specified as per\n[CouchDB doc](http://docs.couchdb.org/en/latest/api/database/bulk-api.html#post--db-_all_docs).\nadditional query string `params` can be specified, `include_docs` is always set\nto `true`.\n\n```js\nconst keys = ['tiger', 'zebra', 'donkey'];\nalice.fetch({keys: keys}).then((data) => {\n  console.log(data);\n});\n```\n\n### db.fetchRevs(docnames, [params], [callback])\n\n** changed in version 6 **\n\nBulk fetch of the revisions of the database documents, `docnames` are specified as per\n[CouchDB doc](http://docs.couchdb.org/en/latest/api/database/bulk-api.html#post--db-_all_docs).\nadditional query string `params` can be specified, this is the same method as fetch but\n `include_docs` is not automatically set to `true`.\n\n### db.createIndex(indexDef, [callback])\n\nCreate index on database fields, as specified in\n[CouchDB doc](http://docs.couchdb.org/en/latest/api/database/find.html#db-index).\n\n```js\nconst indexDef = {\n  index: { fields: ['foo'] },\n  name: 'fooindex'\n};\nalice.createIndex(indexDef).then((result) => {\n  console.log(result);\n});\n```\n\n## Multipart functions\n\n### db.multipart.insert(doc, attachments, params, [callback])\n\nInserts a `doc` together with `attachments` and `params`. If params is a string, it's assumed as the intended document `_id`. If params is an object, its passed as query string parameters and `docName` is checked for defining the `_id`. Refer to the [doc](http://wiki.apache.org/couchdb/HTTP_Document_API#Multiple_Attachments) for more details.\n The `attachments` parameter must be an array of objects with `name`, `data` and `content_type` properties.\n\n```js\nconst fs = require('fs');\n\nfs.readFile('rabbit.png', (err, data) => {\n  if (!err) {\n    alice.multipart.insert({ foo: 'bar' }, [{name: 'rabbit.png', data: data, content_type: 'image/png'}], 'mydoc').then((body) => {\n      console.log(body);\n    });\n  }\n});\n```\n\n### db.multipart.get(docname, [params], [callback])\n\nGet `docname` together with its attachments via `multipart/related` request with optional query string additions `params`. Refer to the\n [doc](http://wiki.apache.org/couchdb/HTTP_Document_API#Getting_Attachments_With_a_Document) for more details. The multipart response body is a `Buffer`.\n\n```js\nalice.multipart.get('rabbit').then((buffer) => {\n  console.log(buffer.toString());\n});\n```\n\n## Attachments functions\n\n### db.attachment.insert(docname, attname, att, contenttype, [params], [callback])\n\nInserts an attachment `attname` to `docname`, in most cases\n `params.rev` is required. Refer to the\n [CouchDB doc](http://docs.couchdb.org/en/latest/api/document/attachments.html#db-doc-attachment) for more details.\n\n```js\nconst fs = require('fs');\n\nfs.readFile('rabbit.png', (err, data) => {\n  if (!err) {\n    alice.attachment.insert('rabbit', 'rabbit.png', data, 'image/png',\n      { rev: '12-150985a725ec88be471921a54ce91452' }).then((body) => {\n        console.log(body);\n    });\n  }\n});\n```\n\n### db.attachment.insertAsStream(docname, attname, att, contenttype, [params])\n\nIt may be more memory-efficient to pipe a stream of data from a source (file, network etc) to a CouchDB attachment:\n\n```js\n  const rs = fs.createReadStream('logo.png');\n  const is = db.attachment.insertAsStream('mydoc', 'logo.png', null, 'image/png',\n    { rev: '12-150985a725ec88be471921a54ce91452' }).on('end', () => {\n      console.log('done')\n  });\n  rs.pipe(is);\n```\n\n### db.attachment.get(docname, attname, [params], [callback])\n\nGet `docname`'s attachment `attname` with optional query string additions\n`params`.\n\n```js\nconst fs = require('fs');\n\nalice.attachment.get('rabbit', 'rabbit.png').then((body) => {\n  fs.writeFile('rabbit.png', body);\n});\n```\n\n### db.attachment.getAsStream(docname, attname, [params])\n\n```js\nconst fs = require('fs');\n\nalice.attachment.getAsStream('rabbit', 'rabbit.png').pipe(fs.createWriteStream('rabbit.png'));\n```\n\n### db.attachment.destroy(docname, attname, [params], [callback])\n\n**changed in version 6**\n\nDestroy attachment `attname` of `docname`'s revision `rev`.\n\n```js\nalice.attachment.destroy('rabbit', 'rabbit.png',\n    {rev: '1-4701d73a08ce5c2f2983bf7c9ffd3320'}).then((body) => {\n       console.log(body);\n});\n```\n\n## Views and design functions\n\n### db.view(designname, viewname, [params], [callback])\n\nCalls a view of the specified `designname` with optional query string `params`. If you're looking to filter the view results by key(s) pass an array of keys, e.g\n`{ keys: ['key1', 'key2', 'key_n'] }`, as `params`.\n\n```js\nalice.view('characters', 'happy_ones', {\n  'key': 'Tea Party',\n  'include_docs': true\n}).then((body) => {\n  body.rows.forEach((doc) => {\n    console.log(doc.value);\n  });\n});\n```\n\nor\n\n```js\nalice.view('characters', 'soldiers', {\n  'keys': ['Hearts', 'Clubs']\n}).then((body) => {\n  body.rows.forEach((doc) => {\n    console.log(doc.value);\n  });\n});\n```\n\nWhen `params` is not supplied, or no keys are specified, it will simply return all documents in the view:\n\n```js\nalice.view('characters', 'happy_ones').then((body) => {\n  body.rows.forEach((doc) => {\n    console.log(doc.value);\n  });\n});\n```\n\n```js\nalice.view('characters', 'happy_ones', { include_docs: true }).then((body) => {\n  body.rows.forEach((doc) => {\n    console.log(doc.value);\n  });\n});\n```\n\n### db.viewAsStream(designname, viewname, [params])\n\nSame as `db.view` but returns a stream:\n\n```js\nalice.view('characters', 'happy_ones', {reduce: false}).pipe(process.stdout);\n```\n\n### db.viewWithList(designname, viewname, listname, [params], [callback])\n\nCalls a list function fed by the given view from the specified design document.\n\n```js\nalice.viewWithList('characters', 'happy_ones', 'my_list').then((body) => {\n  console.log(body);\n});\n```\n\n### db.show(designname, showname, doc_id, [params], [callback])\n\nCalls a show function from the specified design for the document specified by doc_id with\noptional query string additions `params`.\n\n```js\nalice.show('characters', 'format_doc', '3621898430').then((doc) => {\n  console.log(doc);\n});\n```\n\nTake a look at the [couchdb wiki](http://wiki.apache.org/CouchDB/Formatting_with_Show_and_List#Showing_Documents)\nfor possible query paramaters and more information on show functions.\n\n### db.atomic(designname, updatename, docname, [body], [callback])\n\nCalls the design's update function with the specified doc in input.\n\n```js\ndb.atomic(\"update\", \"inplace\", \"foobar\",\n{field: \"foo\", value: \"bar\"}).then((response) => {\n  console.log(response);\n});\n```\n\nNote that the data is sent in the body of the request.\nAn example update handler follows:\n\n```js\n\"updates\": {\n  \"in-place\" : \"function(doc, req) {\n      var request_body = JSON.parse(req.body);\n\n      var field = request_body.field;\n      var value = request_body.value;\n      var message = 'set ' + field + ' to ' + value;\n      doc[field] = value;\n      return [doc, message];\n  }\"\n}\n```\n\n### db.search(designname, searchname, params, [callback])\n\nCalls a view of the specified design with optional query string additions `params`.\n\n```js\nalice.search('characters', 'happy_ones', { q: 'cat' }).then((doc) => {\n  console.log(doc);\n});\n```\n\nor\n\n```js\nconst drilldown = [['author', 'Dickens']['publisher','Penguin']]\nalice.search('inventory', 'books', { q: '*:*', drilldown: drilldown }).then((doc) => {\n  console.log(doc);\n});\n```\n\nCheck out the tests for a fully functioning example.\n\n### db.searchAsStream(designname, searchname, params)\n\nCalls a view of the specified design with optional query string additions `params`. Returns stream.\n\n```js\nalice.search('characters', 'happy_ones', { q: 'cat' }).pipe(process.stdout);\n```\n\n### db.find(selector, [callback])\n\nPerform a [\"Mango\" query](http://docs.couchdb.org/en/2.1.1/api/database/find.html) by supplying a JavaScript object containing a selector:\n\n```js\n// find documents where the name = \"Brian\" and age > 25.\nconst q = {\n  selector: {\n    name: { \"$eq\": \"Brian\"},\n    age : { \"$gt\": 25 }\n  },\n  fields: [ \"name\", \"age\", \"tags\", \"url\" ],\n  limit:50\n};\nalice.find(q).then((doc) => {\n  console.log(doc);\n});\n```\n\n### db.findAsStream(selector)\n\nPerform a [\"Mango\" query](http://docs.couchdb.org/en/2.1.1/api/database/find.html) by supplying a JavaScript object containing a selector, but return a stream:\n\n```js\n// find documents where the name = \"Brian\" and age > 25.\nconst q = {\n  selector: {\n    name: { \"$eq\": \"Brian\"},\n    age : { \"$gt\": 25 }\n  },\n  fields: [ \"name\", \"age\", \"tags\", \"url\" ],\n  limit:50\n};\nalice.findAsStream(q).pipe(process.stdout);\n```\n\n## using cookie authentication\n\nNano supports making requests using CouchDB's [cookie authentication](http://guide.couchdb.org/editions/1/en/security.html#cookies) functionality. If you initialise *Nano* so that it is cookie-aware, you may call `nano.auth` first to get a session cookie. Nano will behave like a web browser, remembering your session cookie and refreshing it if a new one is received in a future HTTP response.\n\n```js\nconst nano = require('nano')({url: 'http://localhost:5984', requestDefaults: {jar:true}}),\n  username = 'user',\n  userpass = 'pass',\n  db = nano.db.use('mydb');\n\nnano.auth(username, userpass).then((() => {\n  return db.get('mydoc');\n}).then((doc) => {\n  console.log(doc);\n});\n```\n\nThe second request works because the `nano` library has remembered the `AuthSession` cookie that was invisibily returned by the `nano.auth` call.\n\nWhen you have a session, you can see what permissions you have by calling the `nano.session` function\n\n```js\nnano.session().then((doc) => {\n  console.log(doc)\n  // { userCtx: { roles: [ '_admin', '_reader', '_writer' ], name: 'rita' },  ok: true }\n});\n```\n\n## Advanced features\n\n### Getting uuids\n\nIf your application needs to generate UUIDs, then CouchDB can provide some for you\n\n```js\nnano.uuids(3).then((doc) => {\n  console.log(doc);\n});\n// { uuids: [\n// '5d1b3ef2bc7eea51f660c091e3dffa23',\n// '5d1b3ef2bc7eea51f660c091e3e006ff',\n// '5d1b3ef2bc7eea51f660c091e3e007f0',\n//]}\n```\n\nThe first parameter is the number of uuids to generate. If omitted, it defaults to 1.\n\n### Extending nano\n\n`nano` is minimalistic but you can add your own features with\n`nano.request(opts)`\n\nFor example, to create a function to retrieve a specific revision of the\n`rabbit` document:\n\n```js\nfunction getrabbitrev(rev) {\n  return nano.request({ db: 'alice',\n                 doc: 'rabbit',\n                 method: 'get',\n                 params: { rev: rev }\n               });\n}\n\ngetrabbitrev('4-2e6cdc4c7e26b745c2881a24e0eeece2').then((body) => {\n  console.log(body);\n});\n```\n\n### Pipes\n\nYou can pipe the return values of certain nano functions like other stream. For example if our `rabbit` document has an attachment with name `picture.png` you can pipe it to a `writable stream`:\n\n```js\nconst fs = require('fs');\nconst nano = require('nano')('http://127.0.0.1:5984/');\nconst alice = nano.use('alice');\nalice.attachment.getAsStream('rabbit', 'picture.png').pipe(fs.createWriteStream('/tmp/rabbit.png'));\n```\n\nthen open `/tmp/rabbit.png` and you will see the rabbit picture.\n\nFunctions that return streams instead of a Promise are:\n\n- nano.db.listAsStream\n\nattachment functions:\n\n- db.attachment.getAsStream\n- db.attachment.insertAsStream\n\nand document level functions\n\n- db.listAsStream\n\n## Tutorials, examples in the wild & screencasts\n\n* article: [nano - a minimalistic CouchDB client for nodejs](http://writings.nunojob.com/2011/08/nano-minimalistic-couchdb-client-for-nodejs.html)\n* article: [getting started with Node.js and CouchDB](http://writings.nunojob.com/2011/09/getting-started-with-nodejs-and-couchdb.html)\n* article: [document update handler support](http://jackhq.tumblr.com/post/16035106690/nano-v1-2-x-document-update-handler-support-v1-2-x)\n* article: [nano 3](http://writings.nunojob.com/2012/05/Nano-3.html)\n* article: [securing a site with CouchDB cookie authentication using Node.js and nano](http://codetwizzle.com/articles/couchdb-cookie-authentication-nodejs-nano/)\n* article: [adding copy to nano](http://blog.jlank.com/2012/07/04/adding-copy-to-nano/)\n* article: [how to update a document with nano](http://writings.nunojob.com/2012/07/How-To-Update-A-Document-With-Nano-The-CouchDB-Client-for-Node.js.html)\n* article: [thoughts on development using CouchDB with Node.js](http://tbranyen.com/post/thoughts-on-development-using-couchdb-with-nodejs)\n* example in the wild: [nanoblog](https://github.com/grabbeh/nanoblog)\n\n## Roadmap\n\nCheck [issues][2]\n\n## Tests\n\nTo run (and configure) the test suite simply:\n\n``` sh\ncd nano\nnpm install\nnpm test\n```\n\nAfter adding a new test you can run it individually (with verbose output) using:\n\n``` sh\nnano_env=testing node tests/doc/list.js list_doc_params\n```\n\nwhere `list_doc_params` is the test name.\n\n## Meta\n\n* code: `git clone git://github.com/apache/couchdb-nano.git`\n* home: <http://github.com/apache/couchdb-nano>\n* bugs: <http://github.com/apache/couchdb-nano/issues>\n* build: [![Build Status](https://travis-ci.org/apache/couchdb-nano.svg?branch=master)](https://travis-ci.org/apache/couchdb-nano)\n* deps: [![dependencies Status](https://david-dm.org/apache/couchdb-nano/status.svg)](https://david-dm.org/apache/couchdb-nano)\n* chat: [Freenode IRC @ #couchdb-dev][8]\n\n[1]: http://npmjs.org\n[2]: http://github.com/apache/couchdb-nano/issues\n[4]: https://github.com/apache/couchdb-nano/blob/master/cfg/couch.example.js\n[8]: http://webchat.freenode.net?channels=%23couchdb-dev\n[follow]: https://www.npmjs.com/package/cloudant-follow\n[request]:  https://github.com/request/request\n\n## Release\n\nTo create a new release of nano. Run the following commands on the master branch\n\n```sh\n  npm version {patch|minor|major}\n  github push  origin master --tags\n  npm publish\n```\n",
  "readmeFilename": "README.md",
  "repository": {
    "type": "git",
    "url": "git+ssh://git@github.com/apache/couchdb-nano.git"
  },
  "scripts": {
    "checkcoverage": "istanbul check-coverage --statements 100 --functions 100 --lines 100 --branches 100",
    "coverage": "open coverage/lcov-report/index.html",
    "mocha": "NOCK_OFF=true istanbul cover tape tests/*/*/*.js",
    "mocked": "tape tests/*/*/*.js",
    "standard": "standard --fix",
    "test": "standard && npm run mocha",
    "unmocked": "NOCK_OFF=true tape tests/*/*/*.js"
  },
  "types": "./lib/nano.d.ts",
  "version": "8.0.1"
}
